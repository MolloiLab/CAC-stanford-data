è•bondsÄ¨cell_resultsÖŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bâ¶queued¬§logsêßrunning¬¶outputÜ§body†∞persist_js_state¬§mime™text/plain≤last_run_timestampÀAÿäˇÓu}$∑has_pluto_hook_features¬¨rootassignee¿ßcell_idŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bπdepends_on_disabled_cells¬ßruntimeÕddµpublished_object_keysêßerrored¬Ÿ$c34ae2e3-466f-4280-8786-b0e92dbb2792â¶queued¬§logsêßrunning¬¶outputÜ§body⁄ô<script>const getParentCell = el => el.closest("pluto-cell")

const getHeaders = () => {
	const depth = Math.max(1, Math.min(6, 3)) // should be in range 1:6
	const range = Array.from({length: depth}, (x, i) => i+1) // [1, ..., depth]
	
	const selector = range.map(i => `pluto-notebook pluto-cell h${i}`).join(",")
	return Array.from(document.querySelectorAll(selector))
}

const indent = true
const aside = true

const clickHandler = (event) => {
	const path = (event.path || event.composedPath())
	const toc = path.find(elem => elem?.classList?.contains?.("toc-toggle"))
	if (toc) {
		event.stopImmediatePropagation()
		toc.closest(".plutoui-toc").classList.toggle("hide")
	}
}

document.addEventListener("click", clickHandler)


const render = (el) => html`${el.map(h => {
	const parent_cell = getParentCell(h)

	const a = html`<a 
		class="${h.nodeName}" 
		href="#${parent_cell.id}"
	>${h.innerText}</a>`
	/* a.onmouseover=()=>{
		parent_cell.firstElementChild.classList.add(
			'highlight-pluto-cell-shoulder'
		)
	}
	a.onmouseout=() => {
		parent_cell.firstElementChild.classList.remove(
			'highlight-pluto-cell-shoulder'
		)
	} */
	a.onclick=(e) => {
		e.preventDefault();
		h.scrollIntoView({
			behavior: 'smooth', 
			block: 'start'
		})
	}

	return html`<div class="toc-row">${a}</div>`
})}`

const tocNode = html`<nav class="plutoui-toc">
	<header>
     <span class="toc-toggle open-toc">üìñ</span>
     <span class="toc-toggle closed-toc">üìï</span>
	Table of Contents</header>
	<section></section>
</nav>`

tocNode.classList.toggle("aside", aside)
tocNode.classList.toggle("indent", indent)

const updateCallback = () => {
	tocNode.querySelector("section").replaceWith(
		html`<section>${render(getHeaders())}</section>`
	)
}
updateCallback()
setTimeout(updateCallback, 100)
setTimeout(updateCallback, 1000)
setTimeout(updateCallback, 5000)

const notebook = document.querySelector("pluto-notebook")


// We have a mutationobserver for each cell:
const observers = {
	current: [],
}

const createCellObservers = () => {
	observers.current.forEach((o) => o.disconnect())
	observers.current = Array.from(notebook.querySelectorAll("pluto-cell")).map(el => {
		const o = new MutationObserver(updateCallback)
		o.observe(el, {attributeFilter: ["class"]})
		return o
	})
}
createCellObservers()

// And one for the notebook's child list, which updates our cell observers:
const notebookObserver = new MutationObserver(() => {
	updateCallback()
	createCellObservers()
})
notebookObserver.observe(notebook, {childList: true})

// And finally, an observer for the document.body classList, to make sure that the toc also works when if is loaded during notebook initialization
const bodyClassObserver = new MutationObserver(updateCallback)
bodyClassObserver.observe(document.body, {attributeFilter: ["class"]})

// Hide/show the ToC when the screen gets small
let m = matchMedia("(max-width: 1000px)")
let match_listener = () => 
	tocNode.classList.toggle("hide", m.matches)
match_listener()
m.addListener(match_listener)

invalidation.then(() => {
	notebookObserver.disconnect()
	bodyClassObserver.disconnect()
	observers.current.forEach((o) => o.disconnect())
	document.removeEventListener("click", clickHandler)
	m.removeListener(match_listener)
})

return tocNode
</script><style>
.plutoui-toc {
	--main-bg-color: unset;
	--pluto-output-color: hsl(0, 0%, 36%);
	--pluto-output-h-color: hsl(0, 0%, 21%);
}

@media (prefers-color-scheme: dark) {
	.plutoui-toc {
		--main-bg-color: hsl(0deg 0% 21%);
		--pluto-output-color: hsl(0, 0%, 90%);
		--pluto-output-h-color: hsl(0, 0%, 97%);
	}
}

.plutoui-toc.aside {
	color: var(--pluto-output-color);
	position:fixed;
	right: 1rem;
	top: 5rem;
	width: min(80vw, 300px);
	padding: 10px;
	border: 3px solid rgba(0, 0, 0, 0.15);
	border-radius: 10px;
	box-shadow: 0 0 11px 0px #00000010;
	/* That is, viewport minus top minus Live Docs */
	max-height: calc(100vh - 5rem - 56px);
	overflow: auto;
	z-index: 40;
	background-color: var(--main-bg-color);
	transition: transform 300ms cubic-bezier(0.18, 0.89, 0.45, 1.12);
}

.plutoui-toc.aside.hide {
	transform: translateX(calc(100% - 28px));
}

.plutoui-toc.aside.hide .open-toc,
.plutoui-toc.aside:not(.hide) .closed-toc,
.plutoui-toc:not(.aside) .closed-toc {
	display: none;
}

@media (prefers-reduced-motion) {
  .plutoui-toc.aside {
    transition-duration: 0s;
  }
}

.toc-toggle {
	cursor: pointer;
	padding: 1em;
	margin: -1em;
    margin-right: -0.7em;
}

.plutoui-toc header {
	display: block;
	font-size: 1.5em;
	margin-top: -0.1em;
	margin-bottom: 0.4em;
	padding-bottom: 0.4em;
	margin-left: 0;
	margin-right: 0;
	font-weight: bold;
	border-bottom: 2px solid rgba(0, 0, 0, 0.15);
}

.plutoui-toc section .toc-row {
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	padding-bottom: 2px;
}

.highlight-pluto-cell-shoulder {
	background: rgba(0, 0, 0, 0.05);
	background-clip: padding-box;
}

.plutoui-toc section a {
	text-decoration: none;
	font-weight: normal;
	color: var(--pluto-output-color);
}
.plutoui-toc section a:hover {
	color: var(--pluto-output-h-color);
}

.plutoui-toc.indent section a.H1 {
	font-weight: 700;
	line-height: 1em;
}

.plutoui-toc.indent section a.H1 {
	padding-left: 0px;
}
.plutoui-toc.indent section a.H2 {
	padding-left: 10px;
}
.plutoui-toc.indent section a.H3 {
	padding-left: 20px;
}
.plutoui-toc.indent section a.H4 {
	padding-left: 30px;
}
.plutoui-toc.indent section a.H5 {
	padding-left: 40px;
}
.plutoui-toc.indent section a.H6 {
	padding-left: 50px;
}
</style>∞persist_js_state¬§mime©text/html≤last_run_timestampÀAÿäˇÓ_~≥∑has_pluto_hook_features¬¨rootassignee¿ßcell_idŸ$c34ae2e3-466f-4280-8786-b0e92dbb2792πdepends_on_disabled_cells¬ßruntimeÕØdµpublished_object_keysêßerrored¬Ÿ$60fe5916-a1a6-11ec-1fbe-8952690e9d06â¶queued¬§logsêßrunning¬¶outputÜ§bodyÇ£msgŸxIOError: readdir("/Users/daleblack/Google Drive/Datasets/Canon_Aquilion_One_Vision"): no such file or directory (ENOENT)™stacktraceóÖ§call≥check_channel_stateßinlined√§file´channels.jl§lineÃ™§path≠./channels.jlÖ§callŸItake_unbuffered(::Channel{Tuple{String, Vector{String}, Vector{String}}})ßinlined¬§file´channels.jl§lineÕì§path≠./channels.jlÖ§call•take!ßinlined√§file´channels.jl§lineÕ§path≠./channels.jlÖ§callŸLiterate(::Channel{Tuple{String, Vector{String}, Vector{String}}}, ::Nothing)ßinlined¬§file´channels.jl§lineÕ—§path≠./channels.jlÖ§callßiterateßinlined√§file´channels.jl§lineÕ–§path≠./channels.jlÖ§call∫dcm_list_builder(::String)ßinlined¬§fileßload.jl§line§pathŸ9/home/runner/.julia/packages/DICOMUtils/y9sLG/src/load.jlÖ§callØtop-level scopeßinlined¬§fileŸDintegrated_scoring_script.jl#==#60fe5916-a1a6-11ec-1fbe-8952690e9d06§line§pathŸÄ/home/runner/work/CAC-stanford-data/CAC-stanford-data/julia/integrated_scoring_script.jl#==#60fe5916-a1a6-11ec-1fbe-8952690e9d06∞persist_js_state¬§mimeŸ'application/vnd.pluto.stacktrace+object≤last_run_timestampÀAÿäˇÔ-#´∑has_pluto_hook_features¬¨rootassignee¿ßcell_idŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06πdepends_on_disabled_cells¬ßruntime¿µpublished_object_keysêßerrored√Ÿ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92â¶queued¬§logsêßrunning¬¶outputÜ§bodyÖ¶prefix•Int64®elementsöíí°1™text/plainíí°2™text/plainíí°3™text/plainíí°4™text/plainíí°5™text/plainíí°6™text/plainíí°7™text/plainíí°8™text/plainí	í°9™text/plainí
í¢10™text/plain§type•Array¨prefix_short†®objectid∞d4c7af08e21e632a∞persist_js_state¬§mimeŸ!application/vnd.pluto.tree+object≤last_run_timestampÀAÿäˇÓƒœO∑has_pluto_hook_features¬¨rootassignee•scansßcell_idŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92πdepends_on_disabled_cells¬ßruntimeÕOLµpublished_object_keysêßerrored¬Ÿ$34a6ee83-5c46-4661-910e-925ea33ef625â¶queued¬§logsêßrunning¬¶outputÜ§bodyÇ£msgŸâFailed to precompile CalciumScoring [9c0cb1da-21b1-4615-967b-153e03110a28] to /home/runner/.julia/compiled/v1.6/CalciumScoring/jl_mIXzW8.™stacktraceóÖ§callØerror(::String)ßinlined¬§file®error.jl§line!§path™./error.jlÖ§callŸVcompilecache(::Base.PkgId, ::String, ::Base.PipeEndpoint, ::Base.PipeEndpoint, ::Bool)ßinlined¬§file™loading.jl§lineÕi§path¨./loading.jlÖ§callŸ$compilecache(::Base.PkgId, ::String)ßinlined¬§file™loading.jl§lineÕ1§path¨./loading.jlÖ§call∂_require(::Base.PkgId)ßinlined¬§file™loading.jl§lineÕ§path¨./loading.jlÖ§callµrequire(::Base.PkgId)ßinlined¬§file™loading.jl§lineÕ®§path¨./loading.jlÖ§callªrequire(::Module, ::Symbol)ßinlined¬§file™loading.jl§lineÕõ§path¨./loading.jlÖ§callØtop-level scopeßinlined¬§fileŸDintegrated_scoring_script.jl#==#34a6ee83-5c46-4661-910e-925ea33ef625§line§pathŸÄ/home/runner/work/CAC-stanford-data/CAC-stanford-data/julia/integrated_scoring_script.jl#==#34a6ee83-5c46-4661-910e-925ea33ef625∞persist_js_state¬§mimeŸ'application/vnd.pluto.stacktrace+object≤last_run_timestampÀAÿäˇÏêW‚∑has_pluto_hook_features¬¨rootassignee¿ßcell_idŸ$34a6ee83-5c46-4661-910e-925ea33ef625πdepends_on_disabled_cells¬ßruntime¿µpublished_object_keysêßerrored√±cell_dependenciesÖŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bÑ¥precedence_heuristic	ßcell_idŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6b¥downstream_cells_mapÇ©BASE_PATHëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06¶VENDERëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06≤upstream_cells_mapÄŸ$c34ae2e3-466f-4280-8786-b0e92dbb2792Ñ¥precedence_heuristic	ßcell_idŸ$c34ae2e3-466f-4280-8786-b0e92dbb2792¥downstream_cells_mapÄ≤upstream_cells_mapÅØTableOfContentsêŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06Ñ¥precedence_heuristic	ßcell_idŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06¥downstream_cells_mapÄ≤upstream_cells_mapﬁ 3•mkdirê£CSVëŸ$34a6ee83-5c46-4661-910e-925ea33ef625°>ê¶islessê¶VENDERëŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6b¶lengthê°<ê¨mask_insertsê£pwdê°/ê•scansëŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92©DataFrameê§meanê∞dcm_list_builderê£absê£divêßcollectê¶haskeyê¶medianêßfindallê™DICOMUtilsëŸ$34a6ee83-5c46-4661-910e-925ea33ef625°-ê¢√∑êπDICOMUtils.get_pixel_sizeê°+ê•Arrayê®mask_rodê™Integratedê©BASE_PATHëŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6b¢cdê£sumê¶stringê§Dictê§sqrtê™mask_heartê¶dilateê°^ê¢==ê°:ê™dcm_readerê•isdirê®basenameê§Boolê§sizeê©quantile!ëŸ$34a6ee83-5c46-4661-910e-925ea33ef625©mapwindowê©CSV.writeê•scoreê°~ê•undefê•erodeêŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92Ñ¥precedence_heuristic	ßcell_idŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92¥downstream_cells_mapÅ•scansëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06≤upstream_cells_mapÇ°:êßcollectêŸ$34a6ee83-5c46-4661-910e-925ea33ef625Ñ¥precedence_heuristicßcell_idŸ$34a6ee83-5c46-4661-910e-925ea33ef625¥downstream_cells_mapç£CSVëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06£PkgëŸ$34a6ee83-5c46-4661-910e-925ea33ef625™StatisticsêÆCalciumScoringêßPlutoUIê®PhantomsêØImageMorphologyê•DICOMê©quantile!ëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06™DICOMUtilsëŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06™DataFramesêÆImageFilteringê£GLMê≤upstream_cells_mapÖßPkg.addê£PkgëŸ$34a6ee83-5c46-4661-910e-925ea33ef625¨Pkg.activateê≥Pkg.Registry.updateê©mktempdirê¥cell_execution_orderïŸ$34a6ee83-5c46-4661-910e-925ea33ef625Ÿ$c34ae2e3-466f-4280-8786-b0e92dbb2792Ÿ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92Ÿ$60fe5916-a1a6-11ec-1fbe-8952690e9d06¥last_hot_reload_timeÀ        ©shortpathºintegrated_scoring_script.jlÆprocess_status•ready§pathŸX/home/runner/work/CAC-stanford-data/CAC-stanford-data/julia/integrated_scoring_script.jlÆlast_save_timeÀAÿäˇûﬁ•/™cell_orderïŸ$34a6ee83-5c46-4661-910e-925ea33ef625Ÿ$c34ae2e3-466f-4280-8786-b0e92dbb2792Ÿ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92Ÿ$60fe5916-a1a6-11ec-1fbe-8952690e9d06±published_objectsÄ•nbpkgá≤installed_versionsÄ∞terminal_outputsÄßenabled¬∑restart_recommended_msg¿¥restart_required_msg¿≠busy_packagesê¨instantiated¬´cell_inputsÖŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6bÑßcell_idŸ$ff0a6e93-9c5e-4ac2-af02-ce253b535c6b∞running_disabled¬§codeŸgbegin
	VENDER = "Canon_Aquilion_One_Vision"
	BASE_PATH = "/Users/daleblack/Google Drive/Datasets/"
end;´code_folded¬Ÿ$c34ae2e3-466f-4280-8786-b0e92dbb2792Ñßcell_idŸ$c34ae2e3-466f-4280-8786-b0e92dbb2792∞running_disabled¬§code±TableOfContents()´code_folded¬Ÿ$60fe5916-a1a6-11ec-1fbe-8952690e9d06Ñßcell_idŸ$60fe5916-a1a6-11ec-1fbe-8952690e9d06∞running_disabled¬§code⁄7±for s in scans
	SCAN_NUMBER = s
	root_path = string(BASE_PATH, VENDER)
	dcm_path_list = dcm_list_builder(root_path)
	pth = dcm_path_list[SCAN_NUMBER]
	scan = basename(pth)
	header, dcm_array, slice_thick_ori1 = dcm_reader(pth)

	# Segment Heart
	masked_array, center_insert, mask = mask_heart(header, dcm_array, size(dcm_array, 3)√∑2)

	# Segment Calcium Rod
	calcium_image, slice_CCI, quality_slice, cal_rod_slice = mask_rod(masked_array, header)

	# Calibration Prep
	array_filtered = abs.(mapwindow(median, calcium_image[:, :, cal_rod_slice], (3, 3)))
	bool_arr = array_filtered .> 0
	bool_arr_erode = (((erode(erode(bool_arr)))))
	c_img = calcium_image[:, :, cal_rod_slice-1:cal_rod_slice+1]
	mask_cal_3D = Array{Bool}(undef, size(c_img))
	for z in 1:size(c_img, 3)
		mask_cal_3D[:, :, z] = bool_arr_erode
	end
	cal_insert_mean2 = mean(c_img[mask_cal_3D])
	cal_insert_mean = quantile!(c_img[mask_cal_3D], 0.7)

	# Segment Calcium Inserts
	# Check Best Segmentation
	angles = collect(-10:2:10)
	RMSE_Dict = Dict()
	for angle in angles
		mask_L_HD, mask_M_HD, mask_S_HD, mask_L_MD, mask_M_MD, mask_S_MD, mask_L_LD, mask_M_LD, mask_S_LD = mask_inserts(
		dcm_array, masked_array, header, slice_CCI, center_insert; angle_factor=angle)
	
		arr = masked_array[:, :, slice_CCI-3:slice_CCI+3]
		single_arr = masked_array[:, :, slice_CCI]
		pixel_size = DICOMUtils.get_pixel_size(header)
		œÅ = 0.2 # mg/mm^3
		# Score Large InsertS
		## High Density
		mask_L_HD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_L_HD_3D[:, :, z] = mask_L_HD
		end
		dilated_mask_L_HD = dilate(dilate(mask_L_HD_3D))
		ring_mask_L_HD = dilate(dilate(dilate(dilate(mask_L_HD_3D)))) - dilate(dilate(dilate(mask_L_HD_3D)))
		single_ring_mask_L_HD = Bool.(ring_mask_L_HD[:, :, 3])
		s_bkg_L_HD = mean(single_arr[single_ring_mask_L_HD])
		alg_L_HD = Integrated(arr[mask_L_HD_3D])
		mass_l_hd = score(s_bkg_L_HD, cal_insert_mean, pixel_size, œÅ, alg_L_HD)
	
		## Medium Density
		mask_L_MD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_L_MD_3D[:, :, z] = mask_L_MD
		end
		dilated_mask_L_MD = dilate(dilate(mask_L_MD_3D))
		ring_mask_L_MD = dilate(dilate(dilate(dilate(mask_L_MD_3D)))) - dilate(dilate(dilate(mask_L_MD_3D)))
		single_ring_mask_L_MD = Bool.(ring_mask_L_MD[:, :, 3])
		s_bkg_L_MD = mean(single_arr[single_ring_mask_L_MD])
		alg_L_MD = Integrated(arr[mask_L_MD_3D])
		mass_l_md = score(s_bkg_L_MD, cal_insert_mean, pixel_size, œÅ, alg_L_MD)
	
		## Low Density
		mask_L_LD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_L_LD_3D[:, :, z] = mask_L_LD
		end
		dilated_mask_L_LD = dilate(dilate(mask_L_LD_3D))
		ring_mask_L_LD = dilate(dilate(dilate(dilate(mask_L_LD_3D)))) - dilate(dilate(dilate(mask_L_LD_3D)))
		single_ring_mask_L_LD = Bool.(ring_mask_L_LD[:, :, 3])
		s_bkg_L_LD = mean(single_arr[single_ring_mask_L_LD])
		alg_L_LD = Integrated(arr[mask_L_LD_3D])
		mass_l_ld = score(s_bkg_L_LD, cal_insert_mean, pixel_size, œÅ, alg_L_LD)
		
		# Score Medium Inserts
		## High Density
		mask_M_HD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_M_HD_3D[:, :, z] = mask_M_HD
		end
		dilated_mask_M_HD = dilate(dilate(dilate(dilate(mask_M_HD_3D))))
		ring_mask_M_HD = dilate(dilate(dilate(dilate(dilate(mask_M_HD_3D))))) - dilate(dilate(dilate(dilate(mask_M_HD_3D))))
		single_ring_mask_M_HD = Bool.(ring_mask_M_HD[:, :, 3])
		s_bkg_M_HD = mean(single_arr[single_ring_mask_M_HD])
		alg_M_HD = Integrated(arr[mask_M_HD_3D])
		mass_m_hd = score(s_bkg_M_HD, cal_insert_mean, pixel_size, œÅ, alg_M_HD)
		
		## Medium Density
		mask_M_MD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_M_MD_3D[:, :, z] = mask_M_MD
		end
		dilated_mask_M_MD = dilate(dilate(dilate(dilate(mask_M_MD_3D))))
		ring_mask_M_MD = dilate(dilate(dilate(dilate(dilate(dilate(mask_M_MD_3D)))))) - dilate(dilate(dilate(dilate(dilate(mask_M_MD_3D)))))
		single_ring_mask_M_MD = Bool.(ring_mask_M_MD[:, :, 3])
		s_bkg_M_MD = mean(single_arr[single_ring_mask_M_MD])
		alg_M_MD = Integrated(arr[mask_M_MD_3D])
		mass_m_md = score(s_bkg_M_MD, cal_insert_mean, pixel_size, œÅ, alg_M_MD)
	
		## Low Density
		mask_M_LD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_M_LD_3D[:, :, z] = mask_M_LD
		end
		dilated_mask_M_LD = dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))
		ring_mask_M_LD = dilate(dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))) - dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))
		single_ring_mask_M_LD = Bool.(ring_mask_M_LD[:, :, 3])
		s_bkg_M_LD = mean(single_arr[single_ring_mask_M_LD])
		alg_M_LD = Integrated(arr[mask_M_LD_3D])
		mass_m_ld = score(s_bkg_M_LD, cal_insert_mean, pixel_size, œÅ, alg_M_LD)
		
	
		# Score Small Inserts
		## High Density
		mask_S_HD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_S_HD_3D[:, :, z] = mask_S_HD
		end
		dilated_mask_S_HD = dilate(dilate(dilate(dilate(dilate((mask_S_HD_3D))))))
		ring_mask_S_HD = dilate(dilate(dilate(dilate(dilate(mask_S_HD_3D))))) - dilate(dilate(dilate(dilate(mask_S_HD_3D))))
		single_ring_mask_S_HD = Bool.(ring_mask_S_HD[:, :, 3])
		s_bkg_S_HD = mean(single_arr[single_ring_mask_S_HD])
		alg_S_HD = Integrated(arr[mask_S_HD_3D])
		mass_s_hd = score(s_bkg_S_HD, cal_insert_mean, pixel_size, œÅ, alg_S_HD)
		if mass_s_hd < 0
			mass_s_hd = 0
		end
		mass_s_hd
	
		## Medium Density
		mask_S_MD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_S_MD_3D[:, :, z] = mask_S_MD
		end
		dilated_mask_S_MD = dilate(dilate(dilate(dilate(dilate(mask_S_MD_3D)))))
		ring_mask_S_MD = dilate(dilate(dilate(dilate(dilate(mask_S_MD_3D))))) - dilate(dilate(dilate(dilate(mask_S_MD_3D))))
		single_ring_mask_S_MD = Bool.(ring_mask_S_MD[:, :, 3])
		s_bkg_S_MD = mean(single_arr[single_ring_mask_S_MD])
		alg_S_MD = Integrated(arr[mask_S_MD_3D])
		mass_s_md = score(s_bkg_S_MD, cal_insert_mean, pixel_size, œÅ, alg_S_MD)
		if mass_s_md < 0
			mass_s_md = 0
		end
		mass_s_md
		
		## Low Density
		mask_S_LD_3D = Array{Bool}(undef, size(arr))
		for z in 1:size(arr, 3)
			mask_S_LD_3D[:, :, z] = mask_S_LD
		end
		dilated_mask_S_LD = dilate(dilate(dilate(dilate(dilate(mask_S_LD_3D)))))
		ring_mask_S_LD = dilate(dilate(dilate(dilate(dilate(mask_S_LD_3D))))) - dilate(dilate(dilate(dilate(mask_S_LD_3D))));
		
		single_ring_mask_S_LD = Bool.(ring_mask_S_LD[:, :, 3])
		s_bkg_S_LD = mean(single_arr[single_ring_mask_S_LD])
		alg_S_LD = Integrated(arr[mask_S_LD_3D])
		mass_s_ld = score(s_bkg_S_LD, cal_insert_mean, pixel_size, œÅ, alg_S_LD)
		if mass_s_ld < 0
			mass_s_ld = 0
		end
		mass_s_ld
		
	
		# Results
		density_array = [0, 200, 400, 800]
		inserts = [
			"Low Density",
			"Medium Density",
			"High Density"
		]
		ground_truth_mass_large = [
			19.6,
			39.3,
			78.5
		] # mg
		
		calculated_mass_large = [
			mass_l_ld,
			mass_l_md,
			mass_l_hd
		]
		ground_truth_mass_medium = [
			4.2,
			8.5,
			17.0
		]
		calculated_mass_medium = [
			mass_m_ld,
			mass_m_md,
			mass_m_hd
		]
		ground_truth_mass_small = [
			0.2,
			0.3,
			0.6
		]
		calculated_mass_small = [
			mass_s_ld,
			mass_s_md,
			mass_s_hd
		]
		RMSE_check = sqrt(sum((ground_truth_mass_small .- calculated_mass_small)).^2 / 3)
		RMSE_check += sqrt(sum((ground_truth_mass_medium .- calculated_mass_medium)).^2 / 3)
		num_zero = length(findall(x -> x == 0, calculated_mass_small))
		RMSE_check += num_zero # penalize zero values heavily
		if haskey(RMSE_Dict, "value") == false
			RMSE_Dict["value"] = RMSE_check
			RMSE_Dict["factor"] = angle
		end
		if RMSE_check < RMSE_Dict["value"]
			RMSE_Dict["value"] = RMSE_check
			RMSE_Dict["factor"] = angle
		end
	end

	# Run Top Segmentation
	angle_factor = RMSE_Dict["factor"]
	mask_L_HD, mask_M_HD, mask_S_HD, mask_L_MD, mask_M_MD, mask_S_MD, mask_L_LD, mask_M_LD, mask_S_LD = mask_inserts(
		dcm_array, masked_array, header, slice_CCI, center_insert; angle_factor=angle_factor)

	arr = masked_array[:, :, slice_CCI-3:slice_CCI+3]
	single_arr = masked_array[:, :, slice_CCI]
	pixel_size = DICOMUtils.get_pixel_size(header)
	œÅ = 0.2 # mg/mm^3
	# Score Large InsertS
	## High Density
	mask_L_HD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_L_HD_3D[:, :, z] = mask_L_HD
	end
	dilated_mask_L_HD = dilate(dilate(mask_L_HD_3D))
	ring_mask_L_HD = dilate(dilate(dilate(dilate(mask_L_HD_3D)))) - dilate(dilate(dilate(mask_L_HD_3D)))
	single_ring_mask_L_HD = Bool.(ring_mask_L_HD[:, :, 3])
	s_bkg_L_HD = mean(single_arr[single_ring_mask_L_HD])
	alg_L_HD = Integrated(arr[mask_L_HD_3D])
	mass_l_hd = score(s_bkg_L_HD, cal_insert_mean, pixel_size, œÅ, alg_L_HD)

	## Medium Density
	mask_L_MD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_L_MD_3D[:, :, z] = mask_L_MD
	end
	dilated_mask_L_MD = dilate(dilate(mask_L_MD_3D))
	ring_mask_L_MD = dilate(dilate(dilate(dilate(mask_L_MD_3D)))) - dilate(dilate(dilate(mask_L_MD_3D)))
	single_ring_mask_L_MD = Bool.(ring_mask_L_MD[:, :, 3])
	s_bkg_L_MD = mean(single_arr[single_ring_mask_L_MD])
	alg_L_MD = Integrated(arr[mask_L_MD_3D])
	mass_l_md = score(s_bkg_L_MD, cal_insert_mean, pixel_size, œÅ, alg_L_MD)

	## Low Density
	mask_L_LD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_L_LD_3D[:, :, z] = mask_L_LD
	end
	dilated_mask_L_LD = dilate(dilate(mask_L_LD_3D))
	ring_mask_L_LD = dilate(dilate(dilate(dilate(mask_L_LD_3D)))) - dilate(dilate(dilate(mask_L_LD_3D)))
	single_ring_mask_L_LD = Bool.(ring_mask_L_LD[:, :, 3])
	s_bkg_L_LD = mean(single_arr[single_ring_mask_L_LD])
	alg_L_LD = Integrated(arr[mask_L_LD_3D])
	mass_l_ld = score(s_bkg_L_LD, cal_insert_mean, pixel_size, œÅ, alg_L_LD)
	
	# Score Medium Inserts
	## High Density
	mask_M_HD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_M_HD_3D[:, :, z] = mask_M_HD
	end
	dilated_mask_M_HD = dilate(dilate(dilate(dilate(mask_M_HD_3D))))
	ring_mask_M_HD = dilate(dilate(dilate(dilate(dilate(mask_M_HD_3D))))) - dilate(dilate(dilate(dilate(mask_M_HD_3D))))
	single_ring_mask_M_HD = Bool.(ring_mask_M_HD[:, :, 3])
	s_bkg_M_HD = mean(single_arr[single_ring_mask_M_HD])
	alg_M_HD = Integrated(arr[mask_M_HD_3D])
	mass_m_hd = score(s_bkg_M_HD, cal_insert_mean, pixel_size, œÅ, alg_M_HD)
	
	## Medium Density
	mask_M_MD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_M_MD_3D[:, :, z] = mask_M_MD
	end
	dilated_mask_M_MD = dilate(dilate(dilate(dilate(mask_M_MD_3D))))
	ring_mask_M_MD = dilate(dilate(dilate(dilate(dilate(dilate(mask_M_MD_3D)))))) - dilate(dilate(dilate(dilate(dilate(mask_M_MD_3D)))))
	single_ring_mask_M_MD = Bool.(ring_mask_M_MD[:, :, 3])
	s_bkg_M_MD = mean(single_arr[single_ring_mask_M_MD])
	alg_M_MD = Integrated(arr[mask_M_MD_3D])
	mass_m_md = score(s_bkg_M_MD, cal_insert_mean, pixel_size, œÅ, alg_M_MD)

	## Low Density
	mask_M_LD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_M_LD_3D[:, :, z] = mask_M_LD
	end
	dilated_mask_M_LD = dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))
	ring_mask_M_LD = dilate(dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))) - dilate(dilate(dilate(dilate(dilate(mask_M_LD_3D)))))
	single_ring_mask_M_LD = Bool.(ring_mask_M_LD[:, :, 3])
	s_bkg_M_LD = mean(single_arr[single_ring_mask_M_LD])
	alg_M_LD = Integrated(arr[mask_M_LD_3D])
	mass_m_ld = score(s_bkg_M_LD, cal_insert_mean, pixel_size, œÅ, alg_M_LD)
	

	# Score Small Inserts
	## High Density
	mask_S_HD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_S_HD_3D[:, :, z] = mask_S_HD
	end
	dilated_mask_S_HD = dilate(dilate(dilate(dilate(dilate((mask_S_HD_3D))))))
	ring_mask_S_HD = dilate(dilate(dilate(dilate(dilate(mask_S_HD_3D))))) - dilate(dilate(dilate(dilate(mask_S_HD_3D))))
	single_ring_mask_S_HD = Bool.(ring_mask_S_HD[:, :, 3])
	s_bkg_S_HD = mean(single_arr[single_ring_mask_S_HD])
	alg_S_HD = Integrated(arr[mask_S_HD_3D])
	mass_s_hd = score(s_bkg_S_HD, cal_insert_mean, pixel_size, œÅ, alg_S_HD)
	if mass_s_hd < 0
		mass_s_hd = 0
	end
	mass_s_hd

	## Medium Density
	mask_S_MD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_S_MD_3D[:, :, z] = mask_S_MD
	end
	dilated_mask_S_MD = dilate(dilate(dilate(dilate(dilate(mask_S_MD_3D)))))
	ring_mask_S_MD = dilate(dilate(dilate(dilate(dilate(mask_S_MD_3D))))) - dilate(dilate(dilate(dilate(mask_S_MD_3D))))
	single_ring_mask_S_MD = Bool.(ring_mask_S_MD[:, :, 3])
	s_bkg_S_MD = mean(single_arr[single_ring_mask_S_MD])
	alg_S_MD = Integrated(arr[mask_S_MD_3D])
	mass_s_md = score(s_bkg_S_MD, cal_insert_mean, pixel_size, œÅ, alg_S_MD)
	if mass_s_md < 0
		mass_s_md = 0
	end
	mass_s_md
	
	## Low Density
	mask_S_LD_3D = Array{Bool}(undef, size(arr))
	for z in 1:size(arr, 3)
		mask_S_LD_3D[:, :, z] = mask_S_LD
	end
	dilated_mask_S_LD = dilate(dilate(dilate(dilate(dilate(mask_S_LD_3D)))))
	ring_mask_S_LD = dilate(dilate(dilate(dilate(dilate(mask_S_LD_3D))))) - dilate(dilate(dilate(dilate(mask_S_LD_3D))));
	
	single_ring_mask_S_LD = Bool.(ring_mask_S_LD[:, :, 3])
	s_bkg_S_LD = mean(single_arr[single_ring_mask_S_LD])
	alg_S_LD = Integrated(arr[mask_S_LD_3D])
	mass_s_ld = score(s_bkg_S_LD, cal_insert_mean, pixel_size, œÅ, alg_S_LD)
	if mass_s_ld < 0
		mass_s_ld = 0
	end
	mass_s_ld
	
	# Results
	density_array = [0, 200, 400, 800]
	inserts = [
		"Low Density",
		"Medium Density",
		"High Density"
	]
	ground_truth_mass_large = [
		19.6,
		39.3,
		78.5
	] # mg
	
	calculated_mass_large = [
		mass_l_ld,
		mass_l_md,
		mass_l_hd
	]
	ground_truth_mass_medium = [
		4.2,
		8.5,
		17.0
	]
	calculated_mass_medium = [
		mass_m_ld,
		mass_m_md,
		mass_m_hd
	]
	ground_truth_mass_small = [
		0.2,
		0.3,
		0.6
	]
	calculated_mass_small = [
		mass_s_ld,
		mass_s_md,
		mass_s_hd
	]
	
	df = DataFrame(
		inserts = inserts,
		ground_truth_mass_large = ground_truth_mass_large,
		calculated_mass_large = calculated_mass_large,
		ground_truth_mass_medium = ground_truth_mass_medium,
		calculated_mass_medium = calculated_mass_medium,
		ground_truth_mass_small = ground_truth_mass_small,
		calculated_mass_small = calculated_mass_small
	)

	# Save Results
	if ~isdir(string(cd(pwd, "..") , "/data/output/", VENDER, "_script"))
		mkdir(string(cd(pwd, "..") , "/data/output/", VENDER, "_script"))
	end
	output_path = string(cd(pwd, "..") , "/data/output/", VENDER, "_script", "/", scan, ".csv")
	CSV.write(output_path, df)
end´code_folded¬Ÿ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92Ñßcell_idŸ$7d8366d8-9cc5-49b3-8db3-1b9db6d12c92∞running_disabled¬§codeµscans = collect(1:10)´code_folded¬Ÿ$34a6ee83-5c46-4661-910e-925ea33ef625Ñßcell_idŸ$34a6ee83-5c46-4661-910e-925ea33ef625∞running_disabled¬§code⁄’begin
	let
		using Pkg
		Pkg.activate(mktempdir())
		Pkg.Registry.update()
		Pkg.add("PlutoUI")
		Pkg.add("Statistics")
		Pkg.add("StatsBase")
		Pkg.add("ImageMorphology")
		Pkg.add("ImageFiltering")
		Pkg.add("CSV")
		Pkg.add("DataFrames")
		Pkg.add("GLM")
		Pkg.add(url="https://github.com/JuliaHealth/DICOM.jl")
		Pkg.add(url="https://github.com/Dale-Black/DICOMUtils.jl")
		Pkg.add(url="https://github.com/Dale-Black/Phantoms.jl")
		Pkg.add(url="https://github.com/Dale-Black/CalciumScoring.jl")
	end
	
	using PlutoUI
	using Statistics
	using StatsBase: quantile!
	using ImageMorphology
	using ImageFiltering
	using CSV
	using DataFrames
	using GLM
	using DICOM
	using DICOMUtils
	using Phantoms
	using CalciumScoring
end´code_folded¬´notebook_idŸ$091601de-a1a8-11ec-2121-718cfa66f390´in_temp_dir¬